---
title: 面经
date: 2024-11-24 18:02:12
tags:

---



## 限流工具类怎么实现？

先介绍主流的几种限流方式：

- **固定窗口计数器**，优点是实现简单、易于理解和部署，缺点是可能存在时间不对称以及难以应对突发流量

- **滑动窗口计数器**，优点是能更好应对突发流量，缺点是实现复杂、需要维护窗口的状态

- **令牌桶算法**，优点是能够很好地平滑流量，允许一定程度的突发流量，缺点是需要更多资源来维护令牌桶状态、不能处理长时间的突发流量

- **漏桶算法**，优点是可以按照恒定的速率限制请求且算法相对简单，缺点是不够灵活、无法应对突发流量、可能导致请求延迟

再说（我采用的是**固定窗口计数器限流**）

- 加了一个继承自HttpFilter的限流过滤器在CORS过滤器之后
- 采用filrer对来自同个IP的请求计数（每次请求前加HTTP过滤器）
- 限流工具类的Redis的key是ip地址，value是访问次数
- 编写了多个逻辑的方法以供不同目的的限流，如
  - 针对单次频率限制，请求成功后一段时间不得再发起请求（如点击请求邮件或者手机验证码）
  - 针对一段时间内多次请求的频率限制（如3秒内最多允许20次请求，例如论坛的评论）
  - 针对于需要采取阶段封禁的频率限制（如防止用户频繁申请JWT令牌，如果已经提示无法登录而用户还在请求，那么就封禁更长时间）

## 为什么要用mq进行发送验证码呢？

使用mq可以做持久化功能，防止验证码没发成功或者发送一般宕机情况发生，在大量请求过来的情况下，发邮件本身就是一个比较耗时的操作，线程可能存在被占用完的情况。

## “楼中楼”评论是如何做的？

答：**数据库中额外的引用字段**

- 数据库comment表中有一个quote字段和root字段，如果是一级评论（也就是直接评论帖子）则quote，root字段值均为-1（无效值）
- 如果是评论的评论，那么子评论的quote字段的值为父评论的ID，root字段值为根评论的ID

## 如何在1000个子评论中找到我回复的那个人最上层的子评论，找到整个评论链？

先查当前评论的引用id，然后递归查询最上面那条，直接他的根，引用id都为根评论id

## 布隆过滤器

布隆过滤器是一种数据结构，用于快速判断一个元素是否存在一个集合中，它牺牲一定的准确性为代价，换取了存储空间的极大节省和查询速度的显著提升。在当前项目中我初始化了一个可以存储1百万个元素的布隆过滤器，误码率在0.001，太高的误码率肯呢个会导致性能的缺失，因此我选择了这个，
在创建链接的同时判断布隆过滤器是否存在这个短连接，存在则抛出异常，否则的话，布隆过滤器添加该短连接。

## 缓存3大问题？

- **缓存击穿**：热点数据过期（也就是**热点key问题**处理）
  - 互斥锁更新数据
  - 热点数据永不过期
- **缓存穿透**：请求数据既不在缓存，也不在数据库
  - 缓存空值或者默认值（占用内存大）
  - 使用**布隆过滤器**快速判断数据是否存在（实现复杂）
- **缓存雪崩**：大量缓存数据同时过期，或者redis故障
  - 均匀设置过期时间
  - 互斥锁更新数据
- **Redis故障宕机**
  - 服务熔断
  - 请求限流
  - 构建Redis集群

## redis如何保证消息队列消费业务仅一次？

即使消息队列保证了“至少一次”消费，也可能导致同一条消息被多次投递。网络故障可能导致消息被重新发送。捉着在分布式系统中，多个消费者可能同时处理消息。通过 Redis，我们可以在消费前检查UUID是否已经处理过。即使消息队列保证了“至少一次”消费，